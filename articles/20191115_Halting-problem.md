# 정지 문제(Halting problem)

<p align="right">큰곰(조진식, kunggom@gmail.com)<br />2019년 11월 15일</p>

원래 이번 주에는 소프트웨어 메트릭과 코드 정적 분석에 대해 다뤄볼까 했는데, 글을 구상하는 과정에서 좀 더 이론적인 부분이 필요하겠다 싶어서 핵심 주제를 좀 바꿔봤습니다. 그래서 이번에는 정지 문제라는 것을 소개해볼까 합니다.

## 로또에 대한 어떤 썰

우리는 레벨 1에서 로또 관련 프로그램을 작성했었죠. 그래서 로또 이야기로 시작합니다. 제가 예전에 안양에서 일할 때, 한번은 부장님이 이런 썰을 푼 적이 있습니다.

> 로또 번호에서 각 번호의 총합이 138인 경우가 당첨 확률이 가장 높다는 거 아냐?

논리를 들어보면 이렇습니다. 로또 번호들의 총합은 정규분포(Normal distribution)를 따르는데, 정규분포 그래프를 보면 한가운데가 불룩 솟은 그래프가 나옵니다. 그리고 로또의 각 숫자를 더한 값 중에서 가장 작은 수는 `1 + 2 + 3 + 4 + 5 + 6 = 21`이고, 가장 큰 수는 `45 + 44 + 43 + 42 + 41 + 40 = 255`입니다. `(21 + 255) ÷ 2 = 138`이므로, 정규분포를 고려할 때 각 번호의 총합이 138이 되는 경우가 가장 당첨 확률이 높지 않겠느냐는 것입니다.

![로또 번호들의 총합으로 그린 정규분포 그래프](http://i.imgur.com/49W182J.png)

얼핏 듣기에 그럴싸해 보입니다. 그래서 저는 숫자의 총합이 138 근처가 되는 랜덤 로또 번호 생성 메소드를 하나 만들어봤습니다. 총합이 딱 138로 떨어지는 로또 번호를 만드는 게 힘들 것 같아, 플러스 마이너스 3을 해서 숫자의 합이 135부터 141 사이가 되면 통과하도록 하였지요. 이 메소드의 코드는 크게 중요한 건 아니니 생략합니다.

그런데 문득 ‘정말로 위 메소드로 만든 로또 번호가 당첨 확률을 높일 수 있을까?’라는 의문이 들었습니다. 그래서 이걸 검증해보려고 간단한 테스트 코드를 작성했지요. 임의의 로또 번호를 당첨 번호로 가정했을 때, 제가 만든 메소드를 사용하면 몇 번만에 당첨되는지를 알아내어 출력하는 코드입니다. 이걸 여러 번 실행하고 통계를 내어, 일반적인 랜덤 번호를 생성할 때와 비교하면 검증이 되지 않을까 생각했습니다. 이게 그 테스트 코드입니다.

```java
class LottoTest {
  public static void main(String[] args) {
    int count = 0;
    Lotto winLotto = getRandomLotto();
    Lotto testLotto;

    while (true) {
      count++;
      testLotto = getRandomLottoBetween135And141();
      if (winLotto.equals(testLotto)) {
        System.out.println(count + "번만에 당첨!");
        break;
      }
    }
  }
}
```

보시다시피 이 코드는 당첨 번호와 일치하는 로또 번호가 나올 때까지 무한반복으로 로또 번호를 생성하게끔 되어 있습니다. 그러면 여기서 문제입니다. **과연 이 프로그램은 정상적으로 종료될까요? 아니면 계속 끝나지 않고 무한루프에 빠질까요?**

## 정지 문제의 대두

이런 식으로 주어진 임의의 컴퓨터 프로그램이 언젠가 정상적으로 종료할지, 아니면 무한루프에 빠져서 영원히 실행되는지를 판정하는 문제를 가리켜 **정지 문제(Halting problem)** 라고 합니다. 정지 문제의 엄밀한 정의는 다음과 같습니다.

> 임의의 프로그램과 처음 입력값이 주어졌을 때, 이 프로그램에 입력값을 넣고 실행하면 결과값을 출력하고 멈출지 아니면 영원히 계속 계산할지 판정하라.

1936년, “컴퓨터 과학의 아버지”로 불리는 수학자 앨런 튜링(Alan Turing, 1912~1954)은 귀류법(모순에 의한 증명 방법)을 통해 **정지 문제를 풀 수 있는 알고리즘은 존재하지 않는다**는 것을 논리적으로 증명했습니다. 그 증명 방법을 이해하기 쉽게 바꿔 쓰면 다음과 같습니다.

1. 정지 문제를 풀 수 있는 알고리즘이 있다고 가정한다.
2. 위 알고리즘으로 A라는 프로그램을 만든다. A는 다음과 같이 동작한다.
    1. 임의의 프로그램을 하나 입력받는다.
    2. 입력받은 프로그램이 정상적으로 종료된다면 `true`를 반환한다.
    3. 입력받은 프로그램이 무한루프에 빠진다면 `false`를 반환한다.
3. 프로그램 A에 재귀적으로 프로그램 A를 집어넣으면 `true`가 반환될 것이다.
4. 프로그램 A로 다음과 같은 프로그램 B를 만든다.
    1. 프로그램 B는 다른 프로그램 C를 입력받는다.
    2. 만약 C가 정상적으로 종료되는 프로그램이면 B는 무한루프에 빠진다.
    3. 만약 C가 무한루프에 빠지는 프로그램이면 B는 `true`를 반환한다.
5. **프로그램 B에 재귀적으로 프로그램 B를 집어넣으면 어떤 경우에도 모순이 발생한다.**
    1. 만약 B가 `true`를 반환한다면 A에서 `false`를 반환했다는 뜻이다. 그런데 B는 무한루프에 빠지지 않았으므로 모순된다.
    2. 만약 B가 무한루프에 빠진다면 A 내부에서 무한루프가 발생했거나 혹은 A가 `true`를 반환했기 때문이다. 그런데 A 내부에서 무한루프가 발생했으면 위에서 A에 재귀적으로 A를 집어넣었을 때의 결과와 모순된다. 그리고 A가 `true`라면 B가 무한루프에 빠진 것과 모순된다.
6. **따라서 정지 문제는 알고리즘을 통해 판정할 수 없다.** (undecidable)

## 정지 문제 증명의 참뜻

사실 앨런 튜링의 정지 문제 증명은 쿠르트 괴델(Kurt Gödel, 1906~1978)이라는 수학자가 발표한 ‘불완전성 정리’의 영향을 받은 것입니다. 불완전성 정리의 의미를 거칠게 요약하자면 다음과 같습니다.

“어떤 논리체계 내부에는 그 논리체계 자체만으로는 기계적인 유한한 절차(알고리즘)를 통해 참과 거짓을 결정하거나 증명할 수 없는 명제가 반드시 하나 이상 있다. 만약 그렇지 않다면, 그 논리체계에는 모순이 있다. 따라서, 그 논리체계 자체만으로는 스스로 모순이 없다는 것을 증명할 수 없다. 만약 어떤 논리체계에 모순이 없다는 것을 증명하고 싶다면 그보다 상위의 논리체계를 동원해야만 한다.”

쿠르트 괴델은 이를 정리하며 다음과 같은 명제를 제시했습니다.

> 명제 G: 명제 G는 증명할 수 없다.

이 재귀적인 명제의 모순은 위에서 본 정지 문제와 유사합니다. 정확히 말하자면, 앨런 튜링은 이 명제를 보고 정지 문제를 생각해내어 증명한 것이지요. 어쨌든, 이러한 원리는 수학을 비롯하여 논리가 들어가는 모든 분야에 적용됩니다. 알고리즘이 적용되는 대표적인 분야인 컴퓨터 프로그래밍 또한 예외가 아니죠.

불완전성 정리나 정지 문제에 나오는 원리를 프로그래밍에 적용하면 **‘어떤 임의의 프로그램이 버그 없이 완전무결한지 보증할 수 있는 일반적인 프로그램은 존재할 수 없다’** 는 결론이 나옵니다. 왜냐하면 그러한 프로그램 역시도 증명하고자 하는 프로그램과 똑같은 논리체계 안에 있는 것이기 때문에 스스로 모순이 있는지 없는지를 증명할 수 없기 때문이지요.

어떤 소프트웨어가 버그가 없이 완전무결하다는 것을 완벽하게 증명할 수 있다면 정말 좋을 것입니다. 응답이 없다며 다운되는 프로그램도 실행 전에 미리 걸러낼 수 있을 것이고, 수많은 사람의 안전을 책임지는 중요한 시스템에서 문제가 생기는 일도 사라지겠지요. 하지만 위 정리에 따르면 그런 증명은 불가능합니다.

## 우린 답을 찾을 것이다, 늘 그랬듯이

그렇다면 컴퓨터가 자동으로 소프트웨어의 버그를 찾아내는 것은 완전히 불가능할까요? 그렇지는 않습니다. 정지 문제의 정의를 다시 살펴보면, 정지 문제가 다루고 있는 것은 *임의의 프로그램*입니다. 다시 말해서 세상에 존재할 수 있는 모든 프로그램들이지요. 이러한 프로그램 중에는 쓸모있는 것보다 쓸모없는 것이 더 많을 것입니다. 그러면 모든 프로그램이 아니라 우리에게 가치가 있는 프로그램만으로 문제의 범위를 좁히면 어떨까요? 아니면, 모든 버그의 증명 대신에 흔히 발생하는 일부 버그로만 문제의 범위를 좁히면 어떨까요? 이런 경우에는 충분히 알고리즘 적용이 가능합니다.

이렇게 소프트웨어에서 문제가 될 수 있는 부분을 자동적으로 찾는 것을 가리켜 **정적 코드 분석**(Static Code Analysis)을 통한 코드 감사(Code audit)라고 합니다. 코드를 실제로 컴파일해서 실행하기 전에 코드의 논리적 흐름을 분석하여, 문제가 발생할 수 있는 부분을 지적해주는 것이죠. Java에서 사용할 수 있는 대표적인 정적 코드 분석 도구로는 [SonarQube](https://www.sonarqube.org/)나 [PMD](https://pmd.github.io/) 같은 것이 있고, 근래에는 페이스북에서 개발한 [Infer](https://fbinfer.com/)라는 도구도 나왔습니다.

사실 우리는 이미 정적 코드 분석을 이미 경험한 바 있습니다. 요즘 나오는 IDE에는 일정 수준의 정적 코드 분석 기능이 이미 내장되어 있거든요. InteliJ IDEA에서 코드 일부분에 주황색 경고 표시가 뜨는 것을 다들 보신 적이 있으실 텐데, 이것도 정적 코드 분석에 의한 기능입니다. 프로그램에 버그가 없다는 것을 완전히 보증할 수는 없지만, 실수하기 쉬운 부분을 바로바로 짚어줘서 버그를 줄이는 데 알게 모르게 도움을 주지요.

## 로또 썰 마무리

이쯤에서 위에서 작성한 로또 관련 코드에 대해 마무리하고 글을 마치도록 하겠습니다.

위에서 예시로 제시되었던 테스트 코드는 잘 보면 정상적으로 종료될지 아니면 무한루프에 빠질지 코드 작성 단계에서는 미리 알 수 없습니다. 왜냐하면 `getRandomLotto()` 메소드의 결과는 랜덤이기 때문에 총합의 범위가 135에서 141 사이가 아닐 수도 있는데, 위 코드대로라면 그런 경우에는 결코 종료 조건을 만족할 수 없어서 무한루프에 빠지기 때문입니다. 하지만 운 좋게 `getRandomLotto()`의 결과가 조건을 만족하면 이 코드는 결과물을 출력할 것입니다.

이런 식으로 코드의 결과가 실행시간(runtime)에 결정되는 알고리즘을 가리켜 ‘비결정적 알고리즘’(Non-deterministic algorithm)이라고 합니다. 랜덤한 요소가 들어가는 알고리즘은 대표적인 비결정적 알고리즘이긴 한데, 이런 식으로 랜덤하게 무한루프에 빠질 수 있는 엉터리 코드는 우리 모두 작성하지 말아야겠습니다.

P. S.

그리고 로또 게임은 숫자의 합을 맞추는 게임이 아니기 때문에, 숫자의 총합을 맞춘 로또 번호를 만든다고 해서 딱히 당첨 확률이 올라가는 것은 아니라고 합니다.

## 참고 - 더 읽어보면 좋은 링크

* [완벽한 백신SW 불가능한 이유, 튜링은 알고 있다 - 종료 문제](http://scienceon.hani.co.kr/34696)
* [MIT 기계공학과 세스 로이드 교수가 말하는 '자유의지에 대한 튜링 테스트'](http://www.joysf.com/4602163)
* [백준 스페셜 저지 - 배중률교](https://www.acmicpc.net/problem/18828)
